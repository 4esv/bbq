# bbq â€” BQN Based Quant
# engine/uni.bqn â€” universe management: multi-asset cross-sectional analysis

bt â† â€¢Import "bt.bqn"

eps â† 1eÂ¯10

# â”€â”€ Universe Construction â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Universe datasets â†’ matrix namespace {close, high, low, open, vol, n_assets, n_bars}
# datasets: list of aligned OHLCV namespaces (from LoadMany or AlignDates)
# close etc. are [n_bars, n_assets] rank-2 arrays (each column = one asset)
Universe â‡ {
  ns â† ğ•©
  na â† â‰ ns
  nb â† â‰ (âŠ‘ns).close
  close    â‡ â‰ > {ğ•©.close}Â¨ ns
  high     â‡ â‰ > {ğ•©.high}Â¨ ns
  low      â‡ â‰ > {ğ•©.low}Â¨ ns
  open     â‡ â‰ > {ğ•©.open}Â¨ ns
  vol      â‡ â‰ > {ğ•©.vol}Â¨ ns
  n_assets â‡ na
  n_bars   â‡ nb
}

# â”€â”€ Cross-Sectional â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# XRank mat â†’ rank matrix (per row, ascending, 0-indexed)
XRank â‡ {â‹â‹ğ•©}Ë˜

# XScore mat â†’ z-score matrix (per row: subtract row mean, divide by row std)
# NOTE: BQN leading-axis broadcast: [nb,na] - [nb] subtracts per-row
XScore â‡ {
  na â† Â¯1âŠ‘â‰¢ğ•©
  row_m â† (+ËË˜ğ•©) Ã· na
  centered â† ğ•© - row_m
  row_v â† (+ËË˜centeredâ‹†2) Ã· na
  row_s â† âˆšrow_vâŒˆeps
  centered Ã· row_s
}

# XWeight mat â†’ weight matrix (per row: value / sum(|row|))
XWeight â‡ {
  abs_sums â† +ËË˜|ğ•©
  ğ•© Ã· abs_sumsâŒˆeps
}

# LongOnly weights â†’ zero negatives, renormalize per row
LongOnly â‡ {
  w â† 0âŒˆğ•©
  row_sums â† +ËË˜w
  denom â† row_sums + row_sums=0
  w Ã· denom
}

# n TopN scores â†’ weight matrix: +1/n for top n, -1/n for bottom n
TopN â‡ {
  n â† ğ•¨
  {
    row â† ğ•©
    na â† â‰ row
    ranked â† â‹â‹row
    long_mask  â† ranked â‰¥ na-n
    short_mask â† ranked < n
    (long_maskÃ·n) - short_maskÃ·n
  }Ë˜ ğ•©
}

# â”€â”€ Strategy Execution â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Strat _UniRun universe â†’ position matrix [n_bars, n_assets]
# Strat: prices (1-D) â†’ positions (1-D), applied per asset column
_UniRun â‡ {
  Strat â† ğ”½ â‹„ uni â† ğ•©
  na â† uni.n_assets
  pos_cols â† {Strat ğ•©âŠ‘Ë˜uni.close}Â¨ â†•na
  â‰ > pos_cols
}

# â”€â”€ Reporting â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# name UniReport weightsâ€¿uni â†’ print universe performance summary
UniReport â‡ {
  name â† ğ•¨
  weightsâ€¿uni â† ğ•©
  na â† uni.n_assets
  nb â† uni.n_bars

  â€¢Out "â•â•â• Universe: " âˆ¾ name âˆ¾ " â•â•â•"
  â€¢Out "Assets: " âˆ¾ (â€¢Fmt na) âˆ¾ "  Bars: " âˆ¾ â€¢Fmt nb
  â€¢Out ""

  # Per-asset returns
  asset_ret â† {bt.Ret ğ•©âŠ‘Ë˜uni.close}Â¨ â†•na

  # Per-asset report
  {
    j â† ğ•© â‹„ r â† jâŠ‘asset_ret
    â€¢Out "  Asset " âˆ¾ (5 bt.Pad â€¢Fmt j) âˆ¾ "  Sharpe: " âˆ¾ (bt.Rd bt.Sharpe r) âˆ¾ "  MaxDD: " âˆ¾ bt.Pct bt.MaxDD r
  }Â¨ â†•na

  # Portfolio returns: (1â†“weights) Ã— ret_mat, summed per bar
  ret_mat â† â‰ > asset_ret
  port_ret â† +ËË˜ (1â†“weights) Ã— ret_mat

  â€¢Out ""
  â€¢Out "Portfolio:"
  â€¢Out "  Sharpe:  " âˆ¾ bt.Rd bt.Sharpe port_ret
  â€¢Out "  MaxDD:   " âˆ¾ bt.Pct bt.MaxDD port_ret
  â€¢Out "  Total:   " âˆ¾ bt.Pct bt.TotalRet port_ret
}
