# bbq â€” BQN Based Quant
# engine/ovf.bqn â€” anti-overfitting metrics

bt  â† â€¢Import "bt.bqn"
opt â† â€¢Import "opt.bqn"

eps â† bt.eps
tdy â† bt.tdy

# â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Ïƒ_SR = sqrt((1 - Î³3Ã—SR + (Î³4-1)/4Ã—SRÂ²) / (T-1))
SRSigma â† {
  srâ€¿skâ€¿kuâ€¿t â† ğ•©
  v â† ((1 - skÃ—sr) + ((ku-1)Ã·4)Ã—srâ‹†2) Ã· 1âŒˆt-1
  âˆš0âŒˆv
}

# â”€â”€ DSR (Deflated Sharpe Ratio) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# n DSR srâ€¿skewâ€¿kurtâ€¿T â†’ scalar in [0,1]
DSR â‡ {
  n â† ğ•¨
  srâ€¿skâ€¿kuâ€¿t â† ğ•©
  eu â† 0.5772156649
  sr_star â† {nâ‰¤1 ? 0 ;
    a â† (1-eu) Ã— opt.PhiInv 1 - 1Ã·n
    b â† eu Ã— opt.PhiInv 1 - 1Ã·n Ã— â‹†1
    (a+b) Ã— âˆš1Ã·1âŒˆt-1
  }
  sig â† SRSigma srâ€¿skâ€¿kuâ€¿t
  opt.Phi (sr - sr_star) Ã· epsâŒˆsig
}

# â”€â”€ PSR (Probabilistic Sharpe Ratio) â”€â”€â”€â”€â”€â”€â”€â”€â”€

# sr_bench PSR srâ€¿Tâ€¿nâ€¿skewâ€¿kurt â†’ scalar in [0,1]
PSR â‡ {
  sr_bench â† ğ•¨
  srâ€¿tâ€¿nâ€¿skâ€¿ku â† ğ•©
  sig â† SRSigma srâ€¿skâ€¿kuâ€¿t
  opt.Phi (sr - sr_bench) Ã· epsâŒˆsig
}

# â”€â”€ MinTRL (Minimum Track Record Length) â”€â”€â”€â”€â”€

# nâ€¿sr MinTRL skewâ€¿kurt â†’ scalar (minimum bars)
MinTRL â‡ {
  nâ€¿sr â† ğ•¨
  skâ€¿ku â† ğ•©
  z â† opt.PhiInv 1 - 0.05Ã·n
  1 + ((1 - skÃ—sr) + ((ku-1)Ã·4)Ã—srâ‹†2) Ã— (zÃ·epsâŒˆsr)â‹†2
}

# â”€â”€ PBO (Probability of Backtest Overfitting) â”€

# PBO wf_result â†’ scalar in [0,1]
PBO â‡ {
  folds â† ğ•©.folds
  n â† â‰ folds
  { n=0 ? 0 ;
    oos â† {ğ•©.test_score}Â¨ folds
    (+Â´oos < 0) Ã· n
  }
}

# â”€â”€ HHI (Return Concentration) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# HHI ret â†’ scalar in [0,1]
HHI â‡ {
  pos â† (ğ•©>0)/ğ•©
  { 0=(+Â´pos) ? 0 ;
    w â† posÃ·+Â´pos
    +Â´wâ‹†2
  }
}

# â”€â”€ TrialCorrect (Benjamini-Hochberg FDR) â”€â”€â”€â”€

# nâ€¿alpha TrialCorrect pvalues â†’ boolean mask (1=reject H0)
TrialCorrect â‡ {
  nâ€¿alpha â† ğ•¨
  pvals â† ğ•©
  m â† â‰ pvals
  order â† â‹pvals
  sorted â† orderâŠpvals
  crit â† (alphaÃ·m) Ã— 1+â†•m
  pass â† sorted â‰¤ crit
  passing â† /pass
  { 0=â‰ passing ? 0Â¨pvals ;
    last_k â† Â¯1âŠ‘passing
    reject_idx â† (1+last_k)â†‘order
    mask â† 0Â¨pvals
    { mask â†© 1âŒ¾(ğ•©âŠ¸âŠ‘) mask }Â¨ reject_idx
    mask
  }
}
