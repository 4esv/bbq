# bbq â€” BQN Based Quant
# engine/mc.bqn â€” Monte Carlo simulation

core â† â€¢Import "core.bqn"
opt â† â€¢Import "opt.bqn"
eps â† core.eps

# â”€â”€ RNG (internal) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Unif n â†’ n uniform floats in (0,1)
Unif â† {(ğ•© â€¢rand.Range 1000000) Ã· 1000000}

# Randn n â†’ n standard normal samples (Box-Muller)
Randn â† {
  half â† âŒˆğ•©Ã·2
  u1 â† epsâŒˆUnif half
  u2 â† Unif half
  r â† âˆš-2Ã—â‹†â¼u1
  a â† 2Ã—Ï€Ã—u2
  ğ•©â†‘(rÃ—â€¢math.Cos a)âˆ¾rÃ—â€¢math.Sin a
}

# â”€â”€ Formatting (internal) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Rd4 â€” round to 4 decimal places
Rd4 â† {
  v â† âŒŠ0.5+10000Ã—|ğ•©
  d â† Â¯4â†‘"0000"âˆ¾â€¢Fmt 10000|v
  ((ğ•©<0)/"-") âˆ¾ (â€¢Fmt âŒŠvÃ·10000) âˆ¾ "." âˆ¾ d
}

# LPad â€” left-pad string to width (right-align)
LPad â† {((ğ•¨-â‰ ğ•©)â¥Š' ')âˆ¾ğ•©}

# â”€â”€ Path Generation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# GbmZ nâ€¿s0â€¿muâ€¿sigâ€¿tâ€¿steps â†’ driftâ€¿diffâ€¿zâ€¿s0 (shared GBM setup)
GbmZ â† {
  nâ€¿s0â€¿muâ€¿sigâ€¿tâ€¿steps â† ğ•©
  dt â† tÃ·steps
  âŸ¨(mu - 0.5Ã—sigâ‹†2) Ã— dt, sig Ã— âˆšdt, nâ€¿steps â¥Š Randn nÃ—steps, s0âŸ©
}

# Paths nâ€¿Sâ‚€â€¿Î¼â€¿Ïƒâ€¿Tâ€¿steps â†’ [n, steps] price paths (GBM)
Paths â‡ {
  driftâ€¿diffâ€¿zâ€¿s0 â† GbmZ ğ•©
  s0 Ã— â‹† +`Ë˜ drift + diffÃ—z
}

# â”€â”€ Payoff Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# k EuroCall path â†’ payoff
EuroCall â‡ {0âŒˆ(Â¯1âŠ‘ğ•©)-ğ•¨}

# k EuroPut path â†’ payoff
EuroPut â‡ {0âŒˆğ•¨-Â¯1âŠ‘ğ•©}

# k AsianCall path â†’ payoff (arithmetic average)
AsianCall â‡ {0âŒˆ((+Â´Ã·â‰ )ğ•©)-ğ•¨}

# kâ€¿barrier BarrierUpOut path â†’ payoff (knocked out if any price â‰¥ barrier)
# NOTE: barrier touch (price = barrier) triggers knockout
BarrierUpOut â‡ {kâ€¿bâ†ğ•¨ â‹„ (âˆ§Â´ğ•©<b) Ã— 0âŒˆ(Â¯1âŠ‘ğ•©)-k}

# â”€â”€ Pricing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Payoff _Price pathsâ€¿râ€¿T â†’ discounted expected payoff
_Price â‡ {
  pathsâ€¿râ€¿t â† ğ•©
  (â‹†-rÃ—t) Ã— (+Â´Ã·â‰ ) ğ”½Ë˜ paths
}

# â”€â”€ Variance Reduction â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Paths _Antithetic config â†’ [2n, steps] (antithetic variates)
_Antithetic â‡ {ğ”½
  driftâ€¿diffâ€¿zâ€¿s0 â† GbmZ ğ•©
  dz â† diffÃ—z
  (s0 Ã— â‹† +`Ë˜ drift+dz) âˆ¾ s0 Ã— â‹† +`Ë˜ drift-dz
}

# â”€â”€ Convergence Test â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Params
s0 â† 100
k â† 100
r â† 0.05
sig â† 0.20
t â† 1
steps â† 252

bsPrice â† opt.BS s0â€¿kâ€¿tâ€¿râ€¿sigâ€¿1

â€¢Out "Monte Carlo vs Black-Scholes Convergence"
â€¢Out "Sâ‚€=100  K=100  r=0.05  Ïƒ=0.20  T=1  steps=252"
â€¢Out "BS analytical: " âˆ¾ Rd4 bsPrice
â€¢Out ""
â€¢Out "  Paths â”‚   MC Price â”‚   BS Price â”‚     Error â”‚    Secs"
â€¢Out "â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€"

{
  n â† ğ•©
  t0 â† â€¢MonoTime@
  paths â† Paths nâ€¿s0â€¿râ€¿sigâ€¿tâ€¿steps
  mcPrice â† kâŠ¸EuroCall _Price pathsâ€¿râ€¿t
  elapsed â† (â€¢MonoTime@)-t0
  err â† mcPrice - bsPrice
  row â† (8 LPad â€¢Fmt n) âˆ¾ " â”‚ " âˆ¾ (10 LPad Rd4 mcPrice) âˆ¾ " â”‚ " âˆ¾ (10 LPad Rd4 bsPrice) âˆ¾ " â”‚ " âˆ¾ (9 LPad Rd4 err) âˆ¾ " â”‚ " âˆ¾ (7 LPad Rd4 elapsed)
  â€¢Out row
}Â¨ 1000â€¿5000â€¿10000â€¿50000â€¿100000
